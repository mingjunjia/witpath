## kvm虚拟化

实现虚拟化的重要一步就在于，虚拟化层必须能够截获计算元件对物理资源的直接访问，并将其重定向到虚拟资源池中。根据虚拟化层是通过纯软件的方法，还是利用物理资源提供的机制来实现这种“截获并重定向”，我们可以把虚拟化层分成软件虚拟化和硬件虚拟化2种。

每个存储卷就是一个完整的系统，运行时将其中的指令载入指定大小的实际物理内存，就像一个普通程序一样，hypervisor就是一个超级的监控器，监控并可以截获这些虚拟机中对设备的指令，对这些指令进行干预。



kvm全称是Kernel Virtual Machine，是基于Linux内核，通过加载新的模块从而使Linux Kernel本身变成一个hypervisor。每个虚拟CPU显示为一个常规线程。一个虚拟机表现为一个进程。

kvm本身不执行任何模拟，需要用户空间程序通过/dev/kvm接口设置一个客户机虚拟服务器的地址空间，向它提供模拟的I/O，并将他的视频显示映射回显示屏，这个程序就是qemu。

kvm模块的主要功能是初始化CPU硬件，打开虚拟化模式，然后将客户机运行在虚拟机模式下，将宿主操作系统置于虚拟化模式中的根模式，并对虚拟客户机的运行提供一定支持。最后，kvm模块创建特殊的设备文件/dev/kvm并等待来自用户空间的命令(qemu)，在这里，创建虚拟机可以理解为，kvm为某个特定的客户机(用户空间程序创建并初始化)创建对应的内核数据结构，同时返回文件句柄来代表所创建的虚拟机。

**在非根模式下，所有敏感的二进制指令都会被处理器捕捉到，处理器在保存现场后自动切换到根模式，由kvm决定如何进一步处理(或者由用户空间的qemu处理)。要硬件虚拟化支持**

除了处理器虚拟化，内存虚拟化也是由kvm实现的，其他大量是qemu实现的。

*从qemu的角度看，也可以说qemuqemu使用了kvm模块的虚拟化功能，为自己的虚拟机提供硬件虚拟化加速。*



普通的Linux进程有2中执行模式，用户模式，内核模式，在kvm环境中，增加了第三种模式--客户模式。



kvm中的客户机是一个qemu进程，宿主机没有特殊对待而分配特定的内存，只把他当做一个普通的Linux进程，内核在进程请求更多的内存时，才会分配更多给他。

可用物理内存和交换空间之合应大于给所有客户机的内存总和。

